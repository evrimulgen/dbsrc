
--    Copyright 2019 Steve Rutledge
--    =========================================================================
--    This file is part of DBSRC Librarian.
--
--    DBSRC Librarian is free software: you can redistribute it and/or modify
--    it under the terms of the GNU General Public License as published by
--    the Free Software Foundation, version 3 of the License.
--
--    DBSRC Librarian is distributed in the hope that it will be useful,
--    but WITHOUT ANY WARRANTY; without even the implied warranty of
--    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--    GNU General Public License for more details.
--
--    You should have received a copy of the GNU General Public License
--    along with DBSRC Librarian (see file COPYING.txt).  
--    If not, see <https://www.gnu.org/licenses/>.
--    =========================================================================

-- ============================================================================
-- INVOCATION	sqlplus -s user/pw@db @get_create_ordered_dbscript (set_no)
--
--			set_no is optional and defaults to max(dbsrc.set_no)
--
-- DESCRIPTION
--
-- get_create_ordered dbscript.sql: get the "object creation" database script,
-- articifically ordered by object type, in alphabetic order.
--
-- The resulting script is named in the pattern of "[cfg_name]_create_ordered.sql".
--
-- ============================================================================

prompt -- BEGIN get_create_ordered_dbscript...

-- appropriate sqlplus settings for batch spooling to a file
@@_init_batch

-- no headers needed for this output!
set pages 0;
col text for a32767 wrap;

-- stop immediately if something blows up, to minimize wasted time
whenever sqlerror exit rollback;

-- Sqlplus makes this awkward: we want the crnt_dbsrc view to default to the
--  latest dbsrc (the max dbsrc_set_no). But, we also want to have the
--  option to instead pass in a different set_no on the cmdline.
-- The below wierdness does just that: set dbsrc.mgr.set_no to cmdline parm, 
--	else default to 1
column 1 new_value 1
select '' "1" from dual where rownum = 0;
exec dbsrc_mgr.set_set_no(&&1);

-- Copy set_no from pl/sql state into sqlplus substitution variable
-- where we can use it from sqlplus stuff.
-- (trim? implicit datatype conversion added spaces, so trim, blah)
col x new_value p_set_no noprint
select trim(dbsrc_mgr.get_set_no()) x from dual;

-- lookup cfg_name for set_no and copy into a sqlplus var
col x new_value p_cfg_name noprint
select dbsrc_mgr.get_cfg_name() x from dual;

-- create a descriptively-named directory to contain all the files we generate.
-- Note, if dir already exists, silently continue
col x new_value p_dirname noprint 
select 'out\&&p_cfg_name' x from dual;
host if not exist "&&p_dirname" mkdir "&&p_dirname"

set termout on
prompt --   Creating &&p_dirname\&&p_cfg_name._created_ordered.sql
set termout off

-- assemble output filename and start spooling
-- Note, if file already exists, silently replace and continue
spool &&p_dirname\&&p_cfg_name._create_ordered.sql

-- =============================================================================
-- (1) render header
-- =============================================================================

prompt -- Generated by DBSRC Library, Copyright Steve Rutledge 2019

select 
    '-- This file was generated on '||sysdate||' by '||user||'@'||
        sys_context('userenv', 'db_name') 
from dual;

prompt -- ============================================================================
prompt -- DESCRIPTION
prompt --;
prompt -- The intent of this script is for it to be readable by human beings, 
prompt -- so objects are grouped and arranged in a logical order intended for 
prompt -- mere humans to find useful. In this script, ddl objects are grouped 
prompt -- by type. The order of types is based on dbsrc_cfg.dbscript.order_no 
prompt -- for this cfg_name, which is typically alphabetic order.
prompt --;
prompt -- Explicitly grouping ddl by type will of course destroy the build
prompt -- dependencies, so don't even try to execute this script.
prompt --;
prompt -- ============================================================================

-- describe the source for the current set_no (summarize the objects in the
-- set, the configuration used to generate this set, etc.).
exec dbsrc_mgr.describe

-- carriage return
select chr(10) from dual;

-- render section in output script to assemble logfile name and start spooling
set def #;
select distinct
    'column logfile new_value v_logfile noprint'||chr(10)||
    'select ''##p_cfg_name._##p_set_no._create_ordered_''||to_char(sysdate,''YYYYMMDD_HH24MISS'')||''.log'' logfile from dual;'||chr(10)||
    'spool &v_logfile'||chr(10)||
    chr(10)||
    'set trimspool on;'||chr(10)||
    'set echo on;'||chr(10)||
    chr(10)||
    'select SYS_CONTEXT (''USERENV'', ''DB_NAME'') as DATABASE, SYS_CONTEXT (''USERENV'', ''SESSION_USER'') as SESSION_USER, SYSDATE from dual;'||chr(10)
from dual;
set def &;

select chr(10) from dual;
prompt -- the dbscript may have embedded ampersands that are NOT substitution variables
prompt set define off;;

prompt -- the dbscript may have blank lines in the middle of a sql statement
prompt set sqlblanklines on;;

-- =============================================================================
-- (2) render body
-- =============================================================================

select chr(10) from dual;
prompt -- ============================================================================
prompt -- script body
prompt -- ============================================================================
select chr(10) from dual;

-- assemble post-processing comment(s) 
-- one per line, in order, for each ddl
with p as (
    select
        s.order_no,
           listagg(
            '-- ('||p.order_no||') '|| 
                regexp_replace(p.comment_text, chr(10), chr(10)||'--      '), 
            chr(10)
         ) within group (order by p.order_no)||chr(10)
        post_prcs_comment_text
    from 
        crnt_dbsrc s
        inner join dbsrc_cfg_post_prcs p
            on p.cfg_name = s.cfg_name and
                instr(s.post_prcs_order_no_list, ':'||p.order_no||':') > 0
    group by s.order_no
--
-- interleave the header and footer text with the dbscript text by 
--  assigning a global order_no
), x as (
    -- header
    select
        (d.order_no * 10000000) order_no,
        d.display_header_text text
    from dbsrc_cfg_dbscript d
    where d.cfg_name = '&&p_cfg_name' and
        --
        -- only show headers with ddl
        exists (
            select 1 from crnt_dbsrc s
            where
                s.dbscript_include_flag = 'Y' and
                s.cfg_name = d.cfg_name and
                s.ddl_type = d.ddl_type
        )
    --
    -- ddl
    union all select
        (s.dbscript_order_no * 10000000) + nvl(s.order_no,0) order_no,
        -- if post-processed, output the post-processing before the ddl
		-- else just output the ddl
        case when p.order_no is not null then
            '-- [dbsrc POST-PROCESSED]:'||chr(10)||p.post_prcs_comment_text
            else null
        end||s.dbsrc_text_cooked text
    from 
        crnt_dbsrc s
		-- not all dbsrc is post-processed, hence left-outer
        left outer join p
            on s.order_no = p.order_no
    where s.dbscript_include_flag = 'Y'
)
select text from x 
order by order_no;

-- =============================================================================
-- (3) render suffix
-- =============================================================================

select
    chr(10)||
    '-- ============='||chr(10)||
    '-- END OF SCRIPT'||chr(10)||
    '-- ============='||chr(10)||
    chr(10)||
    'spool off;'||chr(10)||
    'exit;'||chr(10)||
    chr(10)
from dual;

spool off;

set termout on;
prompt -- END get_create_ordered_dbscript.

-- done!
exit;

